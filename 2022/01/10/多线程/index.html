<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="多线程1、概念多任务边吃饭边看手机，看起来是多个任务，但在同一时间里只做了一件事情 多线程原来只有一条车道，慢慢因为车多了，道路堵塞，效率降低，因此开辟了一条道路 普通方法和多线程 进程(process)和线程(Thread)关系一个进程可以有多个线程，如视频中同时听到声音，看到图片，看弹幕等。一个进程至少有一个线程，线程是CPU调度和执行的单位 很多多线程是模拟出来的，真正的多线程是多个CPU，">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2022/01/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="多线程1、概念多任务边吃饭边看手机，看起来是多个任务，但在同一时间里只做了一件事情 多线程原来只有一条车道，慢慢因为车多了，道路堵塞，效率降低，因此开辟了一条道路 普通方法和多线程 进程(process)和线程(Thread)关系一个进程可以有多个线程，如视频中同时听到声音，看到图片，看弹幕等。一个进程至少有一个线程，线程是CPU调度和执行的单位 很多多线程是模拟出来的，真正的多线程是多个CPU，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/01/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B.jpg">
<meta property="og:image" content="http://example.com/2022/01/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B1.jpg">
<meta property="og:image" content="http://example.com/2022/01/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B2.png">
<meta property="article:published_time" content="2022-01-09T16:28:31.963Z">
<meta property="article:modified_time" content="2022-01-10T12:49:19.281Z">
<meta property="article:author" content="Yuu Xii">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/01/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B.jpg">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 6.0.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/2.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">Yuu Xii</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
						<!-- music -->
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">I&#39;m a developer.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="[object Object]" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-多线程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/01/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  	<time datetime="2022-01-09T16:28:31.963Z" itemprop="datePublished">2022-01-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h1 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h1><h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><p>边吃饭边看手机，看起来是多个任务，但在同一时间里只做了一件事情</p>
<h2 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a>多线程</h2><p>原来只有一条车道，慢慢因为车多了，道路堵塞，效率降低，因此开辟了一条道路</p>
<h2 id="普通方法和多线程"><a href="#普通方法和多线程" class="headerlink" title="普通方法和多线程"></a>普通方法和多线程</h2><p><img src="/2022/01/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B.jpg"></p>
<h2 id="进程-process-和线程-Thread-关系"><a href="#进程-process-和线程-Thread-关系" class="headerlink" title="进程(process)和线程(Thread)关系"></a>进程(process)和线程(Thread)关系</h2><p><code>一个进程可以有多个线程，</code>如视频中同时听到声音，看到图片，看弹幕等。<code>一个进程至少有一个线程，线程是CPU调度和执行的单位</code></p>
<p>很多多线程是模拟出来的，<code>真正的多线程是多个CPU，即多核，如服务器</code></p>
<p><code>程序</code>：是指令和数据的有序集合，其本身没有，任何运行的含义，是一个<code>静态</code>的概念</p>
<p><code>进程</code>：是执行程序的一次执行过程，是一个<code>动态的概念，是系统资源分配</code>的单位</p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>1、线程是<code>独立的执行路径</code></p>
<p>2、在程序运行时，后台会有<code>多个路径，如主线程和gc线程</code>（即垃圾回收进程）</p>
<p>3、<code>main（）称之为主线程，为系统的入口</code>，用于执行整个程序</p>
<p>4、在一个进程中，如果开辟了多个线程，<code>线程的运行由调度器安排，调度器与操作系统相关，先后顺序是不能人为的干预的</code></p>
<p>5、对同一份资源操作时，会<code>存在资源抢夺问题，需要加入并发控制</code></p>
<p>6、<code>线程会带来额外的开销</code>，如cpu调度时间，并发控制开销</p>
<p>7、每个线程在自己的工作内存交互，<code>内存控制不当会造成数据不一致</code></p>
<h1 id="2、线程的创建"><a href="#2、线程的创建" class="headerlink" title="2、线程的创建"></a>2、线程的创建</h1><p>Thread class    继承Thread类（重点）</p>
<p>Runnable 实现Runnable接口（重点）</p>
<p>Callable  实现Callable接口（了解）</p>
<h2 id="Thread-class"><a href="#Thread-class" class="headerlink" title="Thread class"></a>Thread class</h2><p><code>继承Thread类，重写run方法，创建对象，调用start（）方法启动，start（）使得交替执行，没有先后顺序</code></p>
<h2 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h2><p><code>一个类继承该接口，重写run方法，创建该类的对象，将Thread实例化并赋给它，再用start</code></p>
<h2 id="Thread方法"><a href="#Thread方法" class="headerlink" title="Thread方法"></a>Thread方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>返回对当前正在执行的线程对象的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure>

<p>使当前正在执行的线程以指定的毫秒数暂停(暂时停止执行)，具体取决于系统定时器和调度程序的精度和准确性。 线程不会丢失任何显示器的所有权。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Thread：1、子类继承Thread类具备多线程能力</p>
<p>​                 2、启动线程：子类对象.start()</p>
<p>​                 3、<code>不建议：避免OOP单继承局限性</code></p>
<p>Runnable：1、实现Runnable具有多线程能力</p>
<p>​                     2、启动线程：传入目标对象+Thread对象.start()</p>
<p>​                     3、推荐：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</p>
<h2 id="实现Callable接口（了解）"><a href="#实现Callable接口（了解）" class="headerlink" title="实现Callable接口（了解）"></a>实现Callable接口（了解）</h2><p>1、<code>实现Callable接口</code>，需要返回值类型</p>
<p>2、<code>重写call方法</code>，需要抛出异常</p>
<p>3、创建目标对象</p>
<p>4、创建执行服务  ExecutorService ser=Executors.newFixedThreadPool(线程个数);</p>
<p>5、提交执行：Futureresult1=ser.submit(线程名称)</p>
<p>6、获取结果：boolean r=result1.get()</p>
<p>7、关闭服务：ser.shutdownNow();</p>
<p><img src="/2022/01/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B1.jpg"></p>
<h2 id="Callable好处"><a href="#Callable好处" class="headerlink" title="Callable好处"></a>Callable好处</h2><p>1、可以定义为返回值</p>
<p>2、可以抛出异常</p>
<h1 id="静态代理（进程的实现原理）"><a href="#静态代理（进程的实现原理）" class="headerlink" title="静态代理（进程的实现原理）"></a>静态代理（进程的实现原理）</h1><p>你：真实角色</p>
<p>婚庆公司：代理你，帮你处理结婚的事情</p>
<p>结婚：实现结婚的接口</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>真实对象和代理对象都要实现同一个接口，<code>代理对象要先代理真实角色</code></p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>代理对象可以实现很多真实对象做不了的事情</p>
<p>真实对象专注做自己的事情</p>
<h1 id="Lamda表达式"><a href="#Lamda表达式" class="headerlink" title="Lamda表达式"></a>Lamda表达式</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p><code>任何接口，如果只包含唯一一个抽象方法</code>，那么他就是一个函数式接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runable</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于函数式接口，我们可以通过lamda表达式来创建该接口的对象</p>
<p><code>最普通 静态内部类 局部内部类  匿名内部类  拉姆达类(lamda)</code></p>
<h2 id="好处-1"><a href="#好处-1" class="headerlink" title="好处"></a>好处</h2><p>避免匿名内部类定义过多</p>
<p>其实质属于函数式编程的概念</p>
<p>对象=()-&gt;{…}</p>
<h2 id="带有参数"><a href="#带有参数" class="headerlink" title="带有参数"></a>带有参数</h2><p>1、直接代入</p>
<p>2、参数类型删去</p>
<p>3、删去括号</p>
<p>4、删去花括号，<code>但只能是一条语句(以上可以一起执行)</code></p>
<p>5、<code>有多个参数类型。去掉参数，用逗号隔开且用括号括起来</code></p>
<h1 id="3、线程状态"><a href="#3、线程状态" class="headerlink" title="3、线程状态"></a>3、线程状态</h1><p><img src="/2022/01/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B2.png"></p>
<p>1000毫秒=1秒</p>
<h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><p>1、推荐线程自己停止下来</p>
<p>2、建议使用一个标志位进行终止变量，当flag=false，则终止线程运行</p>
<p>3、不推荐使用JDK提供的stop()、destroy()方法</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1、设置标识符</p>
<p>2、设置一个公开方法停止线程，转换标识符</p>
<p>3、调用stop方法切换标识符，让线程停止</p>
<h2 id="线程休眠sleep"><a href="#线程休眠sleep" class="headerlink" title="线程休眠sleep"></a>线程休眠sleep</h2><p>1、sleep指定当前线程阻塞的毫秒数</p>
<p><strong>2、sleep存在异常interruptedException</strong></p>
<p>3、sleep时间达到后线程进入就绪状态</p>
<p>4、sleep可以模拟<strong>网络延时、倒计时</strong></p>
<p>5、每一对象都有一把锁，sleep不会释放锁</p>
<h2 id="线程礼让yield"><a href="#线程礼让yield" class="headerlink" title="线程礼让yield"></a>线程礼让yield</h2><p>1、礼让线程，让当前正在执行的线程暂停，但不阻塞</p>
<p>2、将线程从运行状态变为就绪状态</p>
<p><strong>3、让cpu重新调度，礼让不一定成功，看CPU心情</strong></p>
<h2 id="线程合并join"><a href="#线程合并join" class="headerlink" title="线程合并join"></a>线程合并join</h2><p>1、join合并线程，待此线程执行完成后，在执行其他线程，其他线程阻塞</p>
<p><strong>2、可以想象成插队</strong>，执行完插队的内容，在执行主线程</p>
<h2 id="线程状态监测"><a href="#线程状态监测" class="headerlink" title="线程状态监测"></a>线程状态监测</h2><p>NEW 尚未启动线程</p>
<p>RUNNABLE 在Java虚拟机执行的线程处于此状态</p>
<p>BLOOKED 被阻塞</p>
<p>WAITING  正在等待另一个线程执行特定的动作处于此状态</p>
<p>TIMED WAITING 正在等待另一个执行动作达到指定等待时间的线程处于此状态</p>
<p>TERMINATED 已退出的线程</p>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>1、Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行</p>
<p>2、线程的优先级用数字来表示，范围1到10</p>
<p>Thread.MIN_PRIORITY=1</p>
<p>Thread.MAX_PRIORITY=10</p>
<p>Thread.NORN_PRIORITY=5</p>
<p>3、使用以下方式改变或获取优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">getPority <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> xxx)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>4、从数字高的先执行</strong>（但还是得看CPU调度）</p>
<h2 id="守护-daemon-线程"><a href="#守护-daemon-线程" class="headerlink" title="守护(daemon)线程"></a>守护(daemon)线程</h2><p>1、线程分为<strong>用户线程和守护线程</strong></p>
<p>2、虚拟机必须确保用户线程执行完毕<code> main</code></p>
<p>3、虚拟机不用等待守护线程执行完毕<code> gc</code></p>
<p>4、<strong>true为用户线程 false为守护线程</strong></p>
<p>如：后台记录操作日志，监控内存，垃圾回收</p>
<h1 id="4、线程同步机制"><a href="#4、线程同步机制" class="headerlink" title="4、线程同步机制"></a>4、线程同步机制</h1><p><code>并发：同一个对象被多个线程同时操作</code>  例如：两个银行同时取钱</p>
<p>现实生活中，遇到同一个戏院多个人想同时使用，比如食堂排队，每个人先吃饭，<strong>最简单的方式:排队</strong></p>
<p>处理多个线程问题，<strong>多个线程访问同一个对象时</strong>，并且某些线程还想修改这个对象，这时候我们就需要线程同步，线程同步其实就是一种<strong>等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程在使用</strong></p>
<p>形成条件：队列+锁</p>
<p>由于同一进程的多个线程同时共享同一块存储空间，在带来方便的同时，也带来访问冲突问题。为了保证数据在方法中被访问时的正确性，在访问时加入锁机制 <code>synchronized</code> ，<strong>当一个线程获得对象的锁。独占资源。其他线程笔其他对象必须等待，使用后释放锁即可</strong>。但存在以下问题：</p>
<p>1、一个线程持有索会导致其他所有需要此锁的线程挂起</p>
<p>2、在多线程竞争下，加锁、释放锁会导致比较多的<strong>上下文切换和调度延迟，引起性能问题</strong></p>
<p>3、如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，<strong>引起性能问题</strong>。比如：上大号和小号，性能低大号上厕所，小号性能高会等待的久</p>
<h2 id="同步synchronized"><a href="#同步synchronized" class="headerlink" title="同步synchronized"></a>同步synchronized</h2><p>synchronized方法和synchronized块</p>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span>  args)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>synchronized方法<strong>控制对象的访问</strong>，每个对象对应一把锁，每个<strong>synchronized</strong>方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞。方法一旦调用，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程。缺陷：<strong>将一个大的方法声明为synchronized将会影响效率</strong></p>
<h3 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>（Obj）&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Obj称为同步监视器，锁变化的量</strong></p>
<p><strong>Obi可以是任何对象，</strong>但是推荐使用共享资源作为同步监视器</p>
<p>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class【反射中讲解】</p>
<p>同步监视器的执行过程：</p>
<p>1、第一个线程访问，锁定同步监视器，执行其中代码</p>
<p>2、第二个线程访问，发现同步监视器被锁定，无法访问</p>
<p>3、第一个线程访问，解锁同步监视器</p>
<p>4、第二个线程访问，发现同步监视器没有被锁定，然后锁定并访问</p>
<h2 id="juc安全集合"><a href="#juc安全集合" class="headerlink" title="juc安全集合"></a>juc安全集合</h2><p><code>CopyOnWriteArrayList</code>所建立的对象是安全的</p>
<h1 id="5、死锁"><a href="#5、死锁" class="headerlink" title="5、死锁"></a>5、死锁</h1><p>多个线程各自站有一些共享资源，并且互相等待其他线程占有的资源才能运行，<strong>而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，<code>某一个同步块同时拥有”两个以上对象的锁“时，就可能会发生”死锁“问题</code></strong></p>
<p>例如：拿了这个锁，但还想要另一个所，但一个人只能有一个锁</p>
<h2 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h2><p>1、互斥条件：一个资源每次只能被一个进程使用</p>
<p>2、请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放</p>
<p>3、不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺、</p>
<p>4、循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</p>
<p><strong>只要想办法破其中的任意一个或多个条件就可以避免死锁发生</strong></p>
<h1 id="6、Lock锁"><a href="#6、Lock锁" class="headerlink" title="6、Lock锁"></a>6、Lock锁</h1><p>1、通过显示定义同步锁对象来实现同步，同步锁使用了Lock对象充当</p>
<p>2、java.util.concurrent.locks.Lock接口是<strong>控制多个线程对共享资源进行访问的工具，锁提供了对共享资源空间的独占访问，每次只能有一个线程对Lock对象加锁</strong>，线程开始访问共享对象之前先获的Lock对象</p>
<p>3、<strong>ReentrantLock类实现Lock</strong>，<strong>它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的时ReentrantLock，可以显示加锁、释放锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock=<span class="keyword">new</span> ReentratrLock();</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">   	 lock.lock();</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">finally</span>&#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">       <span class="comment">//如果同步代码块有异常，将unlock（）写入finally语句块</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Synchronized和Lock的对比"><a href="#Synchronized和Lock的对比" class="headerlink" title="Synchronized和Lock的对比"></a>Synchronized和Lock的对比</h1><p>1、<strong>Lock是显示锁(手动开启和关闭锁)，synchronized是隐式锁，出了作用域自动释放</strong></p>
<p>2、Lock只有代码块锁，synchronized有代码块锁和方法锁</p>
<p>3、使用Lock锁，JVM将花费较少的时间调度线程，性能更好，并且具有更好的拓展性</p>
<p>优先使用顺序：Lock&gt;同步代码块（已经进入了方法体，分配了相应资源）&gt;同步方法(在方法体之外)</p>
<h1 id="7、线程通信"><a href="#7、线程通信" class="headerlink" title="7、线程通信"></a>7、线程通信</h1><p>分析：这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件</p>
<p>1、对于生产者，没有生产产品之前，要通知消费者等待，而生产了产品之后，又需要马上通知消费者消费</p>
<p>2、对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费</p>
<p><strong>3、在生产者消费者问题中，仅有synchronized是不够的</strong></p>
<p>​      <strong>synchronized可阻止并发更新同一个共享资源，实现了同步</strong></p>
<p>​      <strong>synchronized不能用来实现不同线程之间的消息传递(通信)</strong></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>wait() 表示线程会一直等待，直到其他线程通知，与sleep不同，会释放锁</p>
<p>wait(long times)指定等待的毫秒数</p>
<p>notify() 唤醒一个处于等待状态的线程</p>
<p>notifyAll() 唤醒同一个对象上所有调用wait() 方法的线程，优先级别高的线程优先调查</p>
<p>均为Object类的方法，<strong>都只能在同步方法或者同步代码块中使用</strong>，否则会抛出异常IllegalMonitorStateException</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="（1）并发协作模型”生产者-消费者模式“-gt-管程法"><a href="#（1）并发协作模型”生产者-消费者模式“-gt-管程法" class="headerlink" title="（1）并发协作模型”生产者/消费者模式“-&gt;管程法"></a>（1）并发协作模型”生产者/消费者模式“-&gt;管程法</h3><p>生产者：负责生产数据的模块(可能是方法，对象，线程，进程)</p>
<p>消费者：负责处理数据的模块(可能是方法，对象，线程，进程)</p>
<p>缓冲区：消费者不能直接使用生产者的数据，它们之间有个”缓冲区“</p>
<p><strong>生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据</strong></p>
<h3 id="（2）并发协作模型”生产者-消费者模式“-gt-信号灯法"><a href="#（2）并发协作模型”生产者-消费者模式“-gt-信号灯法" class="headerlink" title="（2）并发协作模型”生产者/消费者模式“-&gt;信号灯法"></a>（2）并发协作模型”生产者/消费者模式“-&gt;信号灯法</h3><p>类似于”停止线程“</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>sleep（） wait（）有try catch</p>
<h1 id="8、线程池"><a href="#8、线程池" class="headerlink" title="8、线程池"></a>8、线程池</h1><p>背景：经常创建和销毁，使用量特别大，比如出现并发情况下的线程，对性能影响很大</p>
<p>思路：提前创建好多个线程，放入线程池中，使用是直接获取，使用完放回池子中，可以避免频繁创建销毁、实现重复利用，类似交通工具</p>
<p>好处：提高响应速度，降低资源耗损，便于线程管理</p>
<p>方法：corePoolSize：核心池的大小</p>
<p>​            maximumPoolSize：最大线程数</p>
<p>​            keepAliveTime：线程没有任务时最多保持多长时间会终止</p>
<p>​            ExecutorService：真正线程池接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见子类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">excute</span><span class="params">(Runnable command)</span> <span class="comment">//执行命令，没有返回值</span></span></span><br><span class="line"><span class="function"><span class="title">Futuresubmit</span><span class="params">(Callabletask)</span>  <span class="comment">//执行命令，有返回值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">shutdown</span><span class="params">()</span>  <span class="comment">//关闭连接池</span></span></span><br></pre></td></tr></table></figure>

<p> Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/01/10/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2022/01/09/%E9%9B%86%E5%90%88/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title"></div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>






</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 Yuu Xii
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>