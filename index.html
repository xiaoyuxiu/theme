<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yuu Xii">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 6.0.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/2.jpg" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">Yuu Xii</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
						<!-- music -->
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">I&#39;m a developer.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="[object Object]" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-多线程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/01/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  	<time datetime="2022-01-09T16:28:31.963Z" itemprop="datePublished">2022-01-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h1 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h1><h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><p>边吃饭边看手机，看起来是多个任务，但在同一时间里只做了一件事情</p>
<h2 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a>多线程</h2><p>原来只有一条车道，慢慢因为车多了，道路堵塞，效率降低，因此开辟了一条道路</p>
<h2 id="普通方法和多线程"><a href="#普通方法和多线程" class="headerlink" title="普通方法和多线程"></a>普通方法和多线程</h2><p><img src="/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B.jpg" alt="img"></p>
<h2 id="进程-process-和线程-Thread-关系"><a href="#进程-process-和线程-Thread-关系" class="headerlink" title="进程(process)和线程(Thread)关系"></a>进程(process)和线程(Thread)关系</h2><p><code>一个进程可以有多个线程，</code>如视频中同时听到声音，看到图片，看弹幕等。<code>一个进程至少有一个线程，线程是CPU调度和执行的单位</code></p>
<p>很多多线程是模拟出来的，<code>真正的多线程是多个CPU，即多核，如服务器</code></p>
<p><code>程序</code>：是指令和数据的有序集合，其本身没有，任何运行的含义，是一个<code>静态</code>的概念</p>
<p><code>进程</code>：是执行程序的一次执行过程，是一个<code>动态的概念，是系统资源分配</code>的单位</p>
<h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>1、线程是<code>独立的执行路径</code></p>
<p>2、在程序运行时，后台会有<code>多个路径，如主线程和gc线程</code>（即垃圾回收进程）</p>
<p>3、<code>main（）称之为主线程，为系统的入口</code>，用于执行整个程序</p>
<p>4、在一个进程中，如果开辟了多个线程，<code>线程的运行由调度器安排，调度器与操作系统相关，先后顺序是不能人为的干预的</code></p>
<p>5、对同一份资源操作时，会<code>存在资源抢夺问题，需要加入并发控制</code></p>
<p>6、<code>线程会带来额外的开销</code>，如cpu调度时间，并发控制开销</p>
<p>7、每个线程在自己的工作内存交互，<code>内存控制不当会造成数据不一致</code></p>
<h1 id="2、线程的创建"><a href="#2、线程的创建" class="headerlink" title="2、线程的创建"></a>2、线程的创建</h1><p>Thread class    继承Thread类（重点）</p>
<p>Runnable 实现Runnable接口（重点）</p>
<p>Callable  实现Callable接口（了解）</p>
<h2 id="Thread-class"><a href="#Thread-class" class="headerlink" title="Thread class"></a>Thread class</h2><p><code>继承Thread类，重写run方法，创建对象，调用start（）方法启动，start（）使得交替执行，没有先后顺序</code></p>
<h2 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h2><p><code>一个类继承该接口，重写run方法，创建该类的对象，将Thread实例化并赋给它，再用start</code></p>
<h2 id="Thread方法"><a href="#Thread方法" class="headerlink" title="Thread方法"></a>Thread方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>返回对当前正在执行的线程对象的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure>

<p>使当前正在执行的线程以指定的毫秒数暂停(暂时停止执行)，具体取决于系统定时器和调度程序的精度和准确性。 线程不会丢失任何显示器的所有权。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Thread：1、子类继承Thread类具备多线程能力</p>
<p>​                 2、启动线程：子类对象.start()</p>
<p>​                 3、<code>不建议：避免OOP单继承局限性</code></p>
<p>Runnable：1、实现Runnable具有多线程能力</p>
<p>​                     2、启动线程：传入目标对象+Thread对象.start()</p>
<p>​                     3、推荐：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</p>
<h2 id="实现Callable接口（了解）"><a href="#实现Callable接口（了解）" class="headerlink" title="实现Callable接口（了解）"></a>实现Callable接口（了解）</h2><p>1、<code>实现Callable接口</code>，需要返回值类型</p>
<p>2、<code>重写call方法</code>，需要抛出异常</p>
<p>3、创建目标对象</p>
<p>4、创建执行服务  ExecutorService ser=Executors.newFixedThreadPool(线程个数);</p>
<p>5、提交执行：Futureresult1=ser.submit(线程名称)</p>
<p>6、获取结果：boolean r=result1.get()</p>
<p>7、关闭服务：ser.shutdownNow();</p>
<p><img src="/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B2.png" alt="img"></p>
<h2 id="Callable好处"><a href="#Callable好处" class="headerlink" title="Callable好处"></a>Callable好处</h2><p>1、可以定义为返回值</p>
<p>2、可以抛出异常</p>
<h1 id="静态代理（进程的实现原理）"><a href="#静态代理（进程的实现原理）" class="headerlink" title="静态代理（进程的实现原理）"></a>静态代理（进程的实现原理）</h1><p>你：真实角色</p>
<p>婚庆公司：代理你，帮你处理结婚的事情</p>
<p>结婚：实现结婚的接口</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>真实对象和代理对象都要实现同一个接口，<code>代理对象要先代理真实角色</code></p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>代理对象可以实现很多真实对象做不了的事情</p>
<p>真实对象专注做自己的事情</p>
<h1 id="Lamda表达式"><a href="#Lamda表达式" class="headerlink" title="Lamda表达式"></a>Lamda表达式</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p><code>任何接口，如果只包含唯一一个抽象方法</code>，那么他就是一个函数式接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runable</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于函数式接口，我们可以通过lamda表达式来创建该接口的对象</p>
<p><code>最普通 静态内部类 局部内部类  匿名内部类  拉姆达类(lamda)</code></p>
<h2 id="好处-1"><a href="#好处-1" class="headerlink" title="好处"></a>好处</h2><p>避免匿名内部类定义过多</p>
<p>其实质属于函数式编程的概念</p>
<p>对象=()-&gt;{…}</p>
<h2 id="带有参数"><a href="#带有参数" class="headerlink" title="带有参数"></a>带有参数</h2><p>1、直接代入</p>
<p>2、参数类型删去</p>
<p>3、删去括号</p>
<p>4、删去花括号，<code>但只能是一条语句(以上可以一起执行)</code></p>
<p>5、<code>有多个参数类型。去掉参数，用逗号隔开且用括号括起来</code></p>
<h1 id="3、线程状态"><a href="#3、线程状态" class="headerlink" title="3、线程状态"></a>3、线程状态</h1><p><img src="/.com//%E5%A4%9A%E7%BA%BF%E7%A8%8B1.jpg" alt="img"></p>
<p>1000毫秒=1秒</p>
<h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><p>1、推荐线程自己停止下来</p>
<p>2、建议使用一个标志位进行终止变量，当flag=false，则终止线程运行</p>
<p>3、不推荐使用JDK提供的stop()、destroy()方法</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1、设置标识符</p>
<p>2、设置一个公开方法停止线程，转换标识符</p>
<p>3、调用stop方法切换标识符，让线程停止</p>
<h2 id="线程休眠sleep"><a href="#线程休眠sleep" class="headerlink" title="线程休眠sleep"></a>线程休眠sleep</h2><p>1、sleep指定当前线程阻塞的毫秒数</p>
<p><strong>2、sleep存在异常interruptedException</strong></p>
<p>3、sleep时间达到后线程进入就绪状态</p>
<p>4、sleep可以模拟<strong>网络延时、倒计时</strong></p>
<p>5、每一对象都有一把锁，sleep不会释放锁</p>
<h2 id="线程礼让yield"><a href="#线程礼让yield" class="headerlink" title="线程礼让yield"></a>线程礼让yield</h2><p>1、礼让线程，让当前正在执行的线程暂停，但不阻塞</p>
<p>2、将线程从运行状态变为就绪状态</p>
<p><strong>3、让cpu重新调度，礼让不一定成功，看CPU心情</strong></p>
<h2 id="线程合并join"><a href="#线程合并join" class="headerlink" title="线程合并join"></a>线程合并join</h2><p>1、join合并线程，待此线程执行完成后，在执行其他线程，其他线程阻塞</p>
<p><strong>2、可以想象成插队</strong>，执行完插队的内容，在执行主线程</p>
<h2 id="线程状态监测"><a href="#线程状态监测" class="headerlink" title="线程状态监测"></a>线程状态监测</h2><p>NEW 尚未启动线程</p>
<p>RUNNABLE 在Java虚拟机执行的线程处于此状态</p>
<p>BLOOKED 被阻塞</p>
<p>WAITING  正在等待另一个线程执行特定的动作处于此状态</p>
<p>TIMED WAITING 正在等待另一个执行动作达到指定等待时间的线程处于此状态</p>
<p>TERMINATED 已退出的线程</p>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>1、Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行</p>
<p>2、线程的优先级用数字来表示，范围1到10</p>
<p>Thread.MIN_PRIORITY=1</p>
<p>Thread.MAX_PRIORITY=10</p>
<p>Thread.NORN_PRIORITY=5</p>
<p>3、使用以下方式改变或获取优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">getPority <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> xxx)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>4、从数字高的先执行</strong>（但还是得看CPU调度）</p>
<h2 id="守护-daemon-线程"><a href="#守护-daemon-线程" class="headerlink" title="守护(daemon)线程"></a>守护(daemon)线程</h2><p>1、线程分为<strong>用户线程和守护线程</strong></p>
<p>2、虚拟机必须确保用户线程执行完毕<code> main</code></p>
<p>3、虚拟机不用等待守护线程执行完毕<code> gc</code></p>
<p>4、<strong>true为用户线程 false为守护线程</strong></p>
<p>如：后台记录操作日志，监控内存，垃圾回收</p>
<h1 id="4、线程同步机制"><a href="#4、线程同步机制" class="headerlink" title="4、线程同步机制"></a>4、线程同步机制</h1><p><code>并发：同一个对象被多个线程同时操作</code>  例如：两个银行同时取钱</p>
<p>现实生活中，遇到同一个戏院多个人想同时使用，比如食堂排队，每个人先吃饭，<strong>最简单的方式:排队</strong></p>
<p>处理多个线程问题，<strong>多个线程访问同一个对象时</strong>，并且某些线程还想修改这个对象，这时候我们就需要线程同步，线程同步其实就是一种<strong>等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程在使用</strong></p>
<p>形成条件：队列+锁</p>
<p>由于同一进程的多个线程同时共享同一块存储空间，在带来方便的同时，也带来访问冲突问题。为了保证数据在方法中被访问时的正确性，在访问时加入锁机制 <code>synchronized</code> ，<strong>当一个线程获得对象的锁。独占资源。其他线程笔其他对象必须等待，使用后释放锁即可</strong>。但存在以下问题：</p>
<p>1、一个线程持有索会导致其他所有需要此锁的线程挂起</p>
<p>2、在多线程竞争下，加锁、释放锁会导致比较多的<strong>上下文切换和调度延迟，引起性能问题</strong></p>
<p>3、如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，<strong>引起性能问题</strong>。比如：上大号和小号，性能低大号上厕所，小号性能高会等待的久</p>
<h2 id="同步synchronized"><a href="#同步synchronized" class="headerlink" title="同步synchronized"></a>同步synchronized</h2><p>synchronized方法和synchronized块</p>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span>  args)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>synchronized方法<strong>控制对象的访问</strong>，每个对象对应一把锁，每个<strong>synchronized</strong>方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞。方法一旦调用，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程。缺陷：<strong>将一个大的方法声明为synchronized将会影响效率</strong></p>
<h3 id="同步块"><a href="#同步块" class="headerlink" title="同步块"></a>同步块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>（Obj）&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Obj称为同步监视器，锁变化的量</strong></p>
<p><strong>Obi可以是任何对象，</strong>但是推荐使用共享资源作为同步监视器</p>
<p>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class【反射中讲解】</p>
<p>同步监视器的执行过程：</p>
<p>1、第一个线程访问，锁定同步监视器，执行其中代码</p>
<p>2、第二个线程访问，发现同步监视器被锁定，无法访问</p>
<p>3、第一个线程访问，解锁同步监视器</p>
<p>4、第二个线程访问，发现同步监视器没有被锁定，然后锁定并访问</p>
<h2 id="juc安全集合"><a href="#juc安全集合" class="headerlink" title="juc安全集合"></a>juc安全集合</h2><p><code>CopyOnWriteArrayList</code>所建立的对象是安全的</p>
<h1 id="5、死锁"><a href="#5、死锁" class="headerlink" title="5、死锁"></a>5、死锁</h1><p>多个线程各自站有一些共享资源，并且互相等待其他线程占有的资源才能运行，<strong>而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，<code>某一个同步块同时拥有”两个以上对象的锁“时，就可能会发生”死锁“问题</code></strong></p>
<p>例如：拿了这个锁，但还想要另一个所，但一个人只能有一个锁</p>
<h2 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h2><p>1、互斥条件：一个资源每次只能被一个进程使用</p>
<p>2、请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放</p>
<p>3、不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺、</p>
<p>4、循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</p>
<p><strong>只要想办法破其中的任意一个或多个条件就可以避免死锁发生</strong></p>
<h1 id="6、Lock锁"><a href="#6、Lock锁" class="headerlink" title="6、Lock锁"></a>6、Lock锁</h1><p>1、通过显示定义同步锁对象来实现同步，同步锁使用了Lock对象充当</p>
<p>2、java.util.concurrent.locks.Lock接口是<strong>控制多个线程对共享资源进行访问的工具，锁提供了对共享资源空间的独占访问，每次只能有一个线程对Lock对象加锁</strong>，线程开始访问共享对象之前先获的Lock对象</p>
<p>3、<strong>ReentrantLock类实现Lock</strong>，<strong>它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的时ReentrantLock，可以显示加锁、释放锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock=<span class="keyword">new</span> ReentratrLock();</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">   	 lock.lock();</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">     </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">finally</span>&#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">       <span class="comment">//如果同步代码块有异常，将unlock（）写入finally语句块</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Synchronized和Lock的对比"><a href="#Synchronized和Lock的对比" class="headerlink" title="Synchronized和Lock的对比"></a>Synchronized和Lock的对比</h1><p>1、<strong>Lock是显示锁(手动开启和关闭锁)，synchronized是隐式锁，出了作用域自动释放</strong></p>
<p>2、Lock只有代码块锁，synchronized有代码块锁和方法锁</p>
<p>3、使用Lock锁，JVM将花费较少的时间调度线程，性能更好，并且具有更好的拓展性</p>
<p>优先使用顺序：Lock&gt;同步代码块（已经进入了方法体，分配了相应资源）&gt;同步方法(在方法体之外)</p>
<h1 id="7、线程通信"><a href="#7、线程通信" class="headerlink" title="7、线程通信"></a>7、线程通信</h1><p>分析：这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件</p>
<p>1、对于生产者，没有生产产品之前，要通知消费者等待，而生产了产品之后，又需要马上通知消费者消费</p>
<p>2、对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费</p>
<p><strong>3、在生产者消费者问题中，仅有synchronized是不够的</strong></p>
<p>​      <strong>synchronized可阻止并发更新同一个共享资源，实现了同步</strong></p>
<p>​      <strong>synchronized不能用来实现不同线程之间的消息传递(通信)</strong></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>wait() 表示线程会一直等待，直到其他线程通知，与sleep不同，会释放锁</p>
<p>wait(long times)指定等待的毫秒数</p>
<p>notify() 唤醒一个处于等待状态的线程</p>
<p>notifyAll() 唤醒同一个对象上所有调用wait() 方法的线程，优先级别高的线程优先调查</p>
<p>均为Object类的方法，<strong>都只能在同步方法或者同步代码块中使用</strong>，否则会抛出异常IllegalMonitorStateException</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="（1）并发协作模型”生产者-消费者模式“-gt-管程法"><a href="#（1）并发协作模型”生产者-消费者模式“-gt-管程法" class="headerlink" title="（1）并发协作模型”生产者/消费者模式“-&gt;管程法"></a>（1）并发协作模型”生产者/消费者模式“-&gt;管程法</h3><p>生产者：负责生产数据的模块(可能是方法，对象，线程，进程)</p>
<p>消费者：负责处理数据的模块(可能是方法，对象，线程，进程)</p>
<p>缓冲区：消费者不能直接使用生产者的数据，它们之间有个”缓冲区“</p>
<p><strong>生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据</strong></p>
<h3 id="（2）并发协作模型”生产者-消费者模式“-gt-信号灯法"><a href="#（2）并发协作模型”生产者-消费者模式“-gt-信号灯法" class="headerlink" title="（2）并发协作模型”生产者/消费者模式“-&gt;信号灯法"></a>（2）并发协作模型”生产者/消费者模式“-&gt;信号灯法</h3><p>类似于”停止线程“</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>sleep（） wait（）有try catch</p>
<h1 id="8、线程池"><a href="#8、线程池" class="headerlink" title="8、线程池"></a>8、线程池</h1><p>背景：经常创建和销毁，使用量特别大，比如出现并发情况下的线程，对性能影响很大</p>
<p>思路：提前创建好多个线程，放入线程池中，使用是直接获取，使用完放回池子中，可以避免频繁创建销毁、实现重复利用，类似交通工具</p>
<p>好处：提高响应速度，降低资源耗损，便于线程管理</p>
<p>方法：corePoolSize：核心池的大小</p>
<p>​            maximumPoolSize：最大线程数</p>
<p>​            keepAliveTime：线程没有任务时最多保持多长时间会终止</p>
<p>​            ExecutorService：真正线程池接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见子类</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">excute</span><span class="params">(Runnable command)</span> <span class="comment">//执行命令，没有返回值</span></span></span><br><span class="line"><span class="function"><span class="title">Futuresubmit</span><span class="params">(Callabletask)</span>  <span class="comment">//执行命令，有返回值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">shutdown</span><span class="params">()</span>  <span class="comment">//关闭连接池</span></span></span><br></pre></td></tr></table></figure>

<p> Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-集合" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/01/09/%E9%9B%86%E5%90%88/" class="article-date">
  	<time datetime="2022-01-09T13:16:23.716Z" itemprop="datePublished">2022-01-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="使用数组的局限性"><a href="#使用数组的局限性" class="headerlink" title="使用数组的局限性"></a>使用数组的局限性</h2><p>如果要存放多个对象，可以使用数组，但是<strong>数组有局限性</strong><br> 比如：声明长度是10的数组。不用的数组就浪费了，超过10的个数，又放不下</p>
<h2 id="ArrayList存放对象"><a href="#ArrayList存放对象" class="headerlink" title="ArrayList存放对象"></a>ArrayList存放对象</h2><p>为了解决数组的局限性，<strong>引入容器类的概念。 最常见的容器类就是<br> ArrayList</strong></p>
<h3 id="容器容量"><a href="#容器容量" class="headerlink" title="容器容量"></a>容器容量</h3><p>会随着对象的增加，自动增长<br>如：只需要不断往容器里增加英雄即可，不用担心会出现数组的边界问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//容器类ArrayLiat用于存放对象</span></span><br><span class="line">		ArrayList heros=<span class="keyword">new</span> ArrayList();</span><br><span class="line">		heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;盖伦&quot;</span>));</span><br><span class="line">		System.out.print(heros.size());</span><br><span class="line">		heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;提莫&quot;</span>));</span><br><span class="line">		System.out.print(heros.size());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="1、增加"><a href="#1、增加" class="headerlink" title="1、增加"></a>1、增加</h4><p><strong>add</strong> 有两种用法：</p>
<p>第一种是直接add对象，把对象加在最后面</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero &quot;</span> + i));</span><br></pre></td></tr></table></figure>

<p>第二种是在指定位置加对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heros.add(<span class="number">3</span>, specialHero);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//容器类ArrayLiat用于存放对象</span></span><br><span class="line">		ArrayList heros=<span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="comment">//初始化五个对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">			heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero+i&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		Hero specialHero = <span class="keyword">new</span> Hero(<span class="string">&quot;special hero&quot;</span>);</span><br><span class="line">		heros.add(specialHero);</span><br><span class="line">		System.out.print(heros.toString());</span><br><span class="line">		Hero hs[]=(Hero[])heros.toArray(<span class="keyword">new</span> Hero[]&#123;&#125;);</span><br><span class="line">		System.out.print(<span class="string">&quot;数组&quot;</span>+hs.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//容器类ArrayLiat用于存放对象</span></span><br><span class="line">		ArrayList heros=<span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="comment">//初始化五个对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">			heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero+i&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		Hero specialHero = <span class="keyword">new</span> Hero(<span class="string">&quot;special hero&quot;</span>);</span><br><span class="line">		heros.add(specialHero);</span><br><span class="line">		System.out.print(heros.toString());</span><br><span class="line">		Hero hs[]=(Hero[])heros.toArray(<span class="keyword">new</span> Hero[]&#123;&#125;);</span><br><span class="line">		System.out.print(<span class="string">&quot;数组&quot;</span>+hs);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、判断是否存在"><a href="#2、判断是否存在" class="headerlink" title="2、判断是否存在"></a>2、判断是否存在</h4><p>通过方法<strong>contains</strong> 判断一个对象是否在容器中</p>
<p><strong>判断标准： 是否是同一个对象，而不是name是否相同</strong></p>
<h4 id="3、获取指定位置的对象"><a href="#3、获取指定位置的对象" class="headerlink" title="3、获取指定位置的对象"></a>3、获取指定位置的对象</h4><p>通过get获取指定位置的对象，如果输入的下标越界，一样会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//容器类ArrayLiat用于存放对象</span></span><br><span class="line">		ArrayList heros=<span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="comment">//初始化五个对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">			heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero+i&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		Hero specialHero = <span class="keyword">new</span> Hero(<span class="string">&quot;special hero&quot;</span>);</span><br><span class="line">		heros.add(specialHero);</span><br><span class="line">		System.out.print(heros.get(<span class="number">5</span>));</span><br><span class="line">		System.out.print(heros.get(<span class="number">6</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、取对象所处的位置"><a href="#4、取对象所处的位置" class="headerlink" title="4、取对象所处的位置"></a>4、取对象所处的位置</h4><p><strong>indexOf</strong>用于判断一个对象在ArrayList中所处的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//容器类ArrayLiat用于存放对象</span></span><br><span class="line">		ArrayList heros=<span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="comment">//初始化五个对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">			heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero+i&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		Hero specialHero = <span class="keyword">new</span> Hero(<span class="string">&quot;special hero&quot;</span>);</span><br><span class="line">		heros.add(specialHero);</span><br><span class="line">		System.out.print(heros);</span><br><span class="line">		System.out.print(<span class="string">&quot;specialHero所在的位   置&quot;</span>+heros.indexOf(specialHero);</span><br><span class="line">		System.out.print(<span class="string">&quot;新的英雄timo所在的位   置&quot;</span>+heros.indexOf(<span class="keyword">new</span> Hero(<span class="string">&quot;timo&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、删除"><a href="#5、删除" class="headerlink" title="5、删除"></a>5、删除</h4><p><strong>remove</strong>用于把对象从ArrayList中删除<br> remove可以根据下标删除ArrayList的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heros.remove(<span class="number">2</span>); </span><br></pre></td></tr></table></figure>

<p>也可以根据对象删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heros.remove(specialHero);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//容器类ArrayLiat用于存放对象</span></span><br><span class="line">		ArrayList heros=<span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="comment">//初始化五个对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">			heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero+i&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		Hero specialHero = <span class="keyword">new</span> Hero(<span class="string">&quot;special hero&quot;</span>);</span><br><span class="line">		heros.add(specialHero);</span><br><span class="line">		System.out.print(heros);</span><br><span class="line">		heros.remove(<span class="number">2</span>);</span><br><span class="line">		System.out.print(<span class="string">&quot;删除下标是2的元素&quot;</span>);</span><br><span class="line">		System.out.print(heros);</span><br><span class="line">		System.out.print(<span class="string">&quot;删除是specialHero&quot;</span>);</span><br><span class="line">		heros.remove(specialHero);</span><br><span class="line">		System.out.print(heros);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6、替换"><a href="#6、替换" class="headerlink" title="6、替换"></a>6、替换</h4><p><strong>set</strong>用于替换指定位置的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//容器类ArrayLiat用于存放对象</span></span><br><span class="line">		ArrayList heros=<span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="comment">//初始化五个对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">			heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero+i&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		Hero specialHero = <span class="keyword">new</span> Hero(<span class="string">&quot;special hero&quot;</span>);</span><br><span class="line">		heros.add(specialHero);</span><br><span class="line">		System.out.print(heros);</span><br><span class="line">		heros.remove(<span class="number">2</span>);</span><br><span class="line">		System.out.print(<span class="string">&quot;删除下标是2的元素&quot;</span>);</span><br><span class="line">		System.out.print(heros);</span><br><span class="line">		System.out.print(<span class="string">&quot;删除是specialHero&quot;</span>);</span><br><span class="line">		heros.remove(specialHero);</span><br><span class="line">		System.out.print(heros);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7、获取大小"><a href="#7、获取大小" class="headerlink" title="7、获取大小"></a>7、获取大小</h4><p><strong>size</strong> 用于获取ArrayList的大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//容器类ArrayLiat用于存放对象</span></span><br><span class="line">		ArrayList heros=<span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="comment">//初始化五个对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">			heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero+i&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		Hero specialHero = <span class="keyword">new</span> Hero(<span class="string">&quot;special hero&quot;</span>);</span><br><span class="line">		heros.add(specialHero);</span><br><span class="line">		System.out.print(heros);</span><br><span class="line">		System.out.print(<span class="string">&quot;获取ArrayList的大小&quot;</span>);</span><br><span class="line">		System.out.print(heros.size());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8、转换为数组"><a href="#8、转换为数组" class="headerlink" title="8、转换为数组"></a>8、转换为数组</h4><p><strong>toArray</strong>可以把一个ArrayList对象转换为数组。<br><strong>需要注意的是，如果要转换为一个Hero数组，那么需要传递一个</strong><u><strong>Hero数组类型</strong></u><strong>的对象给toArray()，这样toArray方法才知道，你希望转换为哪种类型的数组，否则只能转换为Object数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//容器类ArrayLiat用于存放对象</span></span><br><span class="line">		ArrayList heros=<span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="comment">//初始化五个对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">			heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero+i&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		Hero specialHero = <span class="keyword">new</span> Hero(<span class="string">&quot;special hero&quot;</span>);</span><br><span class="line">		heros.add(specialHero);</span><br><span class="line">		System.out.print(heros);</span><br><span class="line">		Hero hs[]=(Hero[])hreos.toArray(<span class="keyword">new</span> Hero[]&#123;&#125;);</span><br><span class="line">		System.out.print(<span class="string">&quot;数组&quot;</span>+hs);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9、把另一个容器所有对象都加进当前容器"><a href="#9、把另一个容器所有对象都加进当前容器" class="headerlink" title="9、把另一个容器所有对象都加进当前容器"></a>9、把另一个容器所有对象都加进当前容器</h4><p><strong>addAll</strong> 把另一个容器所有对象都加进来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//容器类ArrayLiat用于存放对象</span></span><br><span class="line">		ArrayList heros=<span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="comment">//初始化五个对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">			heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero+i&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(<span class="string">&quot;ArrayList heros&quot;</span>+heros);</span><br><span class="line">		ArrayList anotherheros=<span class="keyword">new</span> ArrayList();</span><br><span class="line">		anotherheros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero a&quot;</span>));</span><br><span class="line">		anotherheros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero b&quot;</span>));</span><br><span class="line">		anotherheros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero c&quot;</span>));</span><br><span class="line">		System.out.print(<span class="string">&quot;anotherheros heros&quot;</span>+anotherheros);</span><br><span class="line">		hreos.addAll(anotherheros);</span><br><span class="line">		System.out.print(heros);</span><br><span class="line">		System.out.print(<span class="string">&quot;把另一个ArrayList加入到当前的ArrayList：&quot;</span>);</span><br><span class="line">		System.out.print(heros);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10、清空"><a href="#10、清空" class="headerlink" title="10、清空"></a>10、清空</h4><p><strong>clear</strong> 清空一个ArrayList</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//容器类ArrayLiat用于存放对象</span></span><br><span class="line">		ArrayList heros=<span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="comment">//初始化五个对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">			heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero+i&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(<span class="string">&quot;ArrayList heros&quot;</span>+heros);</span><br><span class="line">		System.out.print(<span class="string">&quot;使用clear清空&quot;</span>);</span><br><span class="line">		System.out.print(heros);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="List框架"><a href="#List框架" class="headerlink" title="List框架"></a>List框架</h2><h4 id="1、ArrayList和List（List为接口）"><a href="#1、ArrayList和List（List为接口）" class="headerlink" title="1、ArrayList和List（List为接口）"></a>1、ArrayList和List（List为接口）</h4><p>**ArrayList实现了接口List  常见的写法会把引用声明为接口List类型  **</p>
<p><strong>注意：是java.util.List,而不是java.awt.List</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"><span class="keyword">import</span> java.util.List</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//容器类ArrayLiat用于存放对象</span></span><br><span class="line">		List heros=<span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="comment">//初始化五个对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">			heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero+i&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(heros.size());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、List接口的方法"><a href="#2、List接口的方法" class="headerlink" title="2、List接口的方法"></a>2、List接口的方法</h4><p>因为ArrayList实现了List接口，所以<strong>List接口的方法ArrayList都实现了。</strong>import java.util.List</p>
<h2 id="泛型-Generic"><a href="#泛型-Generic" class="headerlink" title="泛型 Generic"></a>泛型 Generic</h2><p>不指定泛型的容器，可以存放任何类型的元素<br>指定了泛型的容器，只能存放指定类型的元素以及其子类</p>
<h4 id="泛型的简写"><a href="#泛型的简写" class="headerlink" title="泛型的简写"></a>泛型的简写</h4><p><strong>为了不使编译器出现警告，需要前后都使用泛型，</strong>像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Hero&gt; genericheros = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br></pre></td></tr></table></figure>

<p>不过JDK7提供了一个可以<strong>略微减少代码量的泛型简写</strong>方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Hero&gt; genericheros2 = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>后面的泛型可以用&lt;&gt;来代替</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"><span class="keyword">import</span> java.util.List</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//容器类ArrayLiat用于存放对象</span></span><br><span class="line">		List&lt;Hero&gt; heros=<span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line">		List&lt;Hero&gt; heros2=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="1、用for循环遍历"><a href="#1、用for循环遍历" class="headerlink" title="1、用for循环遍历"></a>1、用for循环遍历</h3><p>通过前面的学习，知道了可以用size()和get()分别得到大小，和获取指定位置的元素，结合for循环就可以遍历出ArrayList的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"><span class="keyword">import</span> java.util.List</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//容器类ArrayLiat用于存放对象</span></span><br><span class="line">		List&lt;Hero&gt; heros=<span class="keyword">new</span> ArrayList&lt;hero&gt;();</span><br><span class="line">		<span class="comment">//初始化五个对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">			heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero+i&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(<span class="string">&quot;----for循环----&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; heros.size();i++)&#123;</span><br><span class="line">			Hero h=heros.get(i);</span><br><span class="line">			System.out.println(h);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、迭代器遍历"><a href="#2、迭代器遍历" class="headerlink" title="2、迭代器遍历"></a>2、迭代器遍历</h3><p>使用<strong>迭代器Iterator</strong>遍历集合中的元素</p>
<p><img src="file:///C:/Users/admin/AppData/Local/Temp/msohtmlclip1/01/clip_image030.jpg" alt="IMG_256"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"><span class="keyword">import</span> java.util.List</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//容器类ArrayLiat用于存放对象</span></span><br><span class="line">		List&lt;Hero&gt; heros=<span class="keyword">new</span> ArrayList&lt;hero&gt;();</span><br><span class="line">		<span class="comment">//初始化五个对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">			heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero+i&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(<span class="string">&quot;----使用Iterator----&quot;</span>);</span><br><span class="line">		Iterator&lt;Hero&gt; it=heros.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			Hero h=it.next();</span><br><span class="line">			System.out.println(<span class="string">&quot;hero name&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;----使用for的Iterator----&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span>(Iterator&lt;Hero&gt; it=heros.iterator();it.hasNext();)&#123;</span><br><span class="line">			Hero h=(Hero)it.next();		</span><br><span class="line">            System.out.println(h);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、增强型for循环"><a href="#3、增强型for循环" class="headerlink" title="3、增强型for循环"></a>3、增强型for循环</h3><p>使用增强型for循环可以<strong>非常方便的遍历ArrayList</strong>中的元素，这是很多开发人员的首选。</p>
<p><strong>不过增强型for循环也有不足：无法用来进行ArrayList的初始化</strong></p>
<p>无法得知当前是第几个元素了，当需要只打印单数元素的时候，就做不到了。<strong>必须再自定下标变量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"><span class="keyword">import</span> java.util.List</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//容器类ArrayLiat用于存放对象</span></span><br><span class="line">		List&lt;Hero&gt; heros=<span class="keyword">new</span> ArrayList&lt;hero&gt;();</span><br><span class="line">		<span class="comment">//初始化五个对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">			heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero+i&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(<span class="string">&quot;----使用增强型for----&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(Hero h : heros)&#123;</span><br><span class="line">            System.out.println(h);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Typora快捷键" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/01/09/Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/" class="article-date">
  	<time datetime="2022-01-09T13:14:51.483Z" itemprop="datePublished">2022-01-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h1><h4 id="什么是Typora"><a href="#什么是Typora" class="headerlink" title="什么是Typora"></a>什么是Typora</h4><p>Typora 是一款<strong>支持实时预览的 Markdown 文本编辑器</strong>。它有 OS X、Windows、Linux 三个平台的版本，并且由于仍在测试中，是<strong>完全免费</strong>的。而Markdown 是用来编写结构化文档的一种纯文本格式，它使我们在双手不离开键盘的情况下，可以对文本进行一定程度的格式排版。</p>
<h4 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h4><p>加粗：ctrl+B</p>
<p>倾斜：ctrl+I</p>
<p>下划线：ctrl+U</p>
<p>标题：ctrl+H</p>
<p>插入链接：ctrl+K</p>
<p>创建表格：ctrl+T</p>
<p>搜索：ctrl+F</p>
<p>搜索并替换：ctrl+H</p>
<p>返回Typora顶部：ctrl+Home</p>
<p>返回Typora底部：ctrl+End</p>
<p>行内代码：ctrl+shift+K</p>
<p>插入图片：右键-复制、ctrl+v</p>
<p>无序列表：ctrl+shift+L</p>
<p>选中某句话：ctrl+L</p>
<p>选中某个单词：ctrl+D</p>
<p>选中相同格式的文字：ctrl+E</p>
<p>删除线：Alt+Shift+5</p>
<p>引用：ctrl+shift+Q</p>
<p>公共块：ctrl+shift+M</p>
<p>撤销：ctrl+Z</p>
<p>一级标题:ctrl+1</p>
<p>二级标题:ctrl+2</p>
<p>三级标题:ctrl+3</p>
<p>四级标题:ctrl+4</p>
<p>五级标题:ctrl+5</p>
<p>六级标题:ctrl+6</p>
<p>输入连续的空格：为每个空格前加一个 <code>\</code> 转义符</p>
<p>软换行：Shift + Enter 完成一次软换行，只在编辑界面可见，当文档被导出时换行会被省略</p>
<p>硬换行： 空格 + 空格 + Shift + Enter 完成一次硬换行，硬换行在文档被导出时将被保留，且没有换段的段后距。</p>
<p>换段：Shift + Enter</p>
<p>emoji 表情：:表情的英文名：</p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://sspai.com/post/54912">https://sspai.com/post/54912</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-HTTP状态码" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/01/09/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/" class="article-date">
  	<time datetime="2022-01-09T13:14:34.356Z" itemprop="datePublished">2022-01-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p>
<p>HTTP状态码的英文为HTTP Status Code。</p>
<p>下面是常见的HTTP状态码：</p>
<ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<h2 id="HTTP状态码分类"><a href="#HTTP状态码分类" class="headerlink" title="HTTP状态码分类"></a>HTTP状态码分类</h2><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">分类描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1**</td>
<td align="left">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td align="left">2**</td>
<td align="left">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td align="left">3**</td>
<td align="left">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td align="left">4**</td>
<td align="left">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td align="left">5**</td>
<td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<p>HTTP状态码列表:</p>
<table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">状态码英文名称</th>
<th align="left">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">Continue</td>
<td align="left">继续。<a target="_blank" rel="noopener" href="http://www.dreamdu.com/webbuild/client_vs_server/">客户端</a>应继续其请求</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">Switching Protocols</td>
<td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">200</td>
<td align="left">OK</td>
<td align="left">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">Created</td>
<td align="left">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td align="left">202</td>
<td align="left">Accepted</td>
<td align="left">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td align="left">203</td>
<td align="left">Non-Authoritative Information</td>
<td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td align="left">204</td>
<td align="left">No Content</td>
<td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="left">205</td>
<td align="left">Reset Content</td>
<td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td align="left">206</td>
<td align="left">Partial Content</td>
<td align="left">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">300</td>
<td align="left">Multiple Choices</td>
<td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="left">301</td>
<td align="left">Moved Permanently</td>
<td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="left">302</td>
<td align="left">Found</td>
<td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="left">303</td>
<td align="left">See Other</td>
<td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td align="left">304</td>
<td align="left">Not Modified</td>
<td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td align="left">305</td>
<td align="left">Use Proxy</td>
<td align="left">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td align="left">306</td>
<td align="left">Unused</td>
<td align="left">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td align="left">307</td>
<td align="left">Temporary Redirect</td>
<td align="left">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">400</td>
<td align="left">Bad Request</td>
<td align="left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td align="left">401</td>
<td align="left">Unauthorized</td>
<td align="left">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="left">402</td>
<td align="left">Payment Required</td>
<td align="left">保留，将来使用</td>
</tr>
<tr>
<td align="left">403</td>
<td align="left">Forbidden</td>
<td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="left">404</td>
<td align="left">Not Found</td>
<td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td align="left">405</td>
<td align="left">Method Not Allowed</td>
<td align="left">客户端请求中的方法被禁止</td>
</tr>
<tr>
<td align="left">406</td>
<td align="left">Not Acceptable</td>
<td align="left">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td align="left">407</td>
<td align="left">Proxy Authentication Required</td>
<td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td align="left">408</td>
<td align="left">Request Time-out</td>
<td align="left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td align="left">409</td>
<td align="left">Conflict</td>
<td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td align="left">410</td>
<td align="left">Gone</td>
<td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td align="left">411</td>
<td align="left">Length Required</td>
<td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td align="left">412</td>
<td align="left">Precondition Failed</td>
<td align="left">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td align="left">413</td>
<td align="left">Request Entity Too Large</td>
<td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td align="left">414</td>
<td align="left">Request-URI Too Large</td>
<td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td align="left">415</td>
<td align="left">Unsupported Media Type</td>
<td align="left">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td align="left">416</td>
<td align="left">Requested range not satisfiable</td>
<td align="left">客户端请求的范围无效</td>
</tr>
<tr>
<td align="left">417</td>
<td align="left">Expectation Failed</td>
<td align="left">服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">500</td>
<td align="left">Internal Server Error</td>
<td align="left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="left">501</td>
<td align="left">Not Implemented</td>
<td align="left">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="left">502</td>
<td align="left">Bad Gateway</td>
<td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td align="left">503</td>
<td align="left">Service Unavailable</td>
<td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="left">504</td>
<td align="left">Gateway Time-out</td>
<td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td align="left">505</td>
<td align="left">HTTP Version not supported</td>
<td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Hexo博客" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/01/09/Hexo%E5%8D%9A%E5%AE%A2/" class="article-date">
  	<time datetime="2022-01-09T13:09:34.923Z" itemprop="datePublished">2022-01-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Hexo博客"><a href="#Hexo博客" class="headerlink" title="Hexo博客"></a>Hexo博客</h1><p>参照博客：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_37781304/article/details/82729029">https://blog.csdn.net/sinat_37781304/article/details/82729029</a></p>
<p>hexo出现错误err（可作为难点）：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c60ad2a33a1e">https://www.jianshu.com/p/c60ad2a33a1e</a></p>
<p>解决头像显示不出的问题：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/litten/hexo-theme-yilia/issues/288">解决头像的问题 · Issue #288 · litten/hexo-theme-yilia · GitHub</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 Yuu Xii
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>